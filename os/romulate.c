/*
 * This tool builds the raw binary ROM image based on the output of building the
 * kernel and other code/data that will be distributed in ROM.
 *
 * The kernel code is remapped to the appropriate physical offsets so that it
 * will at run time in turn appear at the appropriate *logical* offsets in
 * supervisor mode.
 *
 * Other data and code is provided in a very simple ROM filesystem.
 * (Or at least it will be, once there *is* any such data and code.)
 */

#include <stdio.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>
#include <stdint.h>

const int rom_size = 6 * 1024 * 1024;

uint16_t read_elf_16(uint8_t *elf, int ofs) {
    return ((uint16_t)elf[ofs] << 8) | (elf[ofs + 1]);
}

uint32_t read_elf_32(uint8_t *elf, int ofs) {
    return (
        ((uint32_t)elf[ofs] << 24) |
        ((uint32_t)elf[ofs + 1] << 16) |
        ((uint32_t)elf[ofs + 2] << 8) |
        ((uint32_t)elf[ofs + 3])
    );
}

uint64_t read_elf_64(uint8_t *elf, int ofs) {
    return (
        ((uint64_t)elf[ofs] << 56) |
        ((uint64_t)elf[ofs + 1] << 48) |
        ((uint64_t)elf[ofs + 2] << 40) |
        ((uint64_t)elf[ofs + 3] << 32) |
        ((uint64_t)elf[ofs + 4] << 24) |
        ((uint64_t)elf[ofs + 5] << 16) |
        ((uint64_t)elf[ofs + 6] << 8) |
        ((uint64_t)elf[ofs + 7])
    );
}

int write_kernel(int elf_fd, uint8_t *rom) {
    // The idea here is to read the program header out of the kernel ELF
    // file and then translate the segment load addresses from
    // supervisor-logical to physical addresses, relative to the start
    // of the ROM area. That is:
    //     0x400000 - 0x800000 -> 0x000000 - 0x400000 (kernel ROM)
    //     0xa00000 - 0xc00000 -> 0x400000 - 0x600000 (boot init ROM)
    // The former region is permanently mapped in the supervisor memory space,
    // whereas the latter is mapped temporarily during early boot:
    // - At CPU reset it appears at 0x000000 for the initial SP and PC vectors
    // - The early boot code moves it immediately into the two supervisor
    //   selectable memory mapping regions to expose the kernel RAM and then
    //   initalize it using data from the boot init ROM
    //
    // The kernel ELF file is assumed to be a 32-bit M68K ELF file, and
    // no real validation is done of its structure because we're expecting
    // to recieve what was generated by the Makefile in the kernel subdir,
    // which produces its ELF file using GNU ld.

    // The elf shouldn't actually be anywhere near as big as rom_size,
    // but we've got virtual memory to spare and this allows us to lazily
    // avoid determining the file's true size.
    char *elf = mmap(NULL, rom_size, PROT_READ, MAP_PRIVATE, elf_fd, 0);
    if ((void*)elf == (void*)-1) {
        perror("Failed to mmap kernel ELF");
        return -1;
    }

    // Basic validation of the ELF, just so that mistakes get flagged with
    // useful error messages rather than corruption / segfaults.
    if (elf[0] != '\x7f' || elf[1] != 'E' || elf[2] != 'L' || elf[3] != 'F') {
        fprintf(stderr, "kernel ELF isn't actually ELF\n");
        return -1;
    }
    if (elf[4] != 1) {
        fprintf(stderr, "kernel ELF isn't 32-bit\n");
        return -1;
    }
    if (elf[5] != 2) {
        fprintf(stderr, "kernel ELF isn't big-endian\n");
        return -1;
    }

    uint32_t phdr_ofs = read_elf_32(elf, 28);
    uint16_t phdr_len = read_elf_16(elf, 44);
    uint16_t phdr_item_len = read_elf_16(elf, 42);

    for (int i = 0; i < phdr_len; i++) {
        int item_ofs = phdr_ofs + (i * phdr_item_len);
        uint32_t item_type = read_elf_32(elf, item_ofs);
        if (item_type != 1) {
            // Only interested in "LOAD" segments
            continue;
        }

        uint32_t item_data_ofs = read_elf_32(elf, item_ofs + 4);
        uint32_t item_load_addr = read_elf_32(elf, item_ofs + 12);
        uint32_t item_file_size = read_elf_32(elf, item_ofs + 16);
        uint32_t item_mem_size = read_elf_32(elf, item_ofs + 20);

        // For the sake of mapping segments, we assume that the
        // kernel linker script is well-behaved and won't produce
        // any segments that straddle our different virtual memory
        // areas, and thus we can just map the start address and
        // assume the rest will all be in the same segment.

        uint32_t item_rom_addr;
        if (item_load_addr >= 0x400000 && item_load_addr < 0x800000) {
            item_rom_addr = item_load_addr - 0x400000;
        }
        else if (item_load_addr >= 0xa00000 && item_load_addr < 0xc00000) {
            item_rom_addr = item_load_addr - 0x600000;
        }
        else {
            fprintf(stderr, "Kernel segment %i is not in ROM range\n", i);
            return -1;
        }

        char *source = elf + item_data_ofs;
        char *target = rom + item_rom_addr;
        printf("%4i: 0x%08x for %i bytes\n", i, (int)item_rom_addr, (int)item_mem_size);
        memset(target, 0, item_mem_size);
        memcpy(target, source, item_file_size);
    }

}

int main(int argc, char **argv) {
    if (argc != 3) {
        fprintf(
            stderr, "Usage: %s <output-file> <kernel-elf-file>\n\n", argv[0]
        );
        return 1;
    }

    char *out_filename = argv[1];
    char *kernel_elf_filename = argv[2];

    int kernel_elf_fd = open(kernel_elf_filename, O_RDONLY);
    if (kernel_elf_fd == -1) {
        perror("Error opening kernel ELF");
        return 2;
    }

    int out_fd = open(out_filename, O_CREAT|O_RDWR|O_TRUNC, 0664);
    if (out_fd == -1) {
        perror("Error creating output file");
        return 2;
    }

    if (ftruncate(out_fd, rom_size) == -1) {
        perror("Failed to set output file size");
        return 2;
    }

    uint8_t *rom = mmap(
        NULL, rom_size, PROT_READ|PROT_WRITE, MAP_SHARED, out_fd, 0
    );
    if ((void*)rom == (void*)-1) {
        perror("Failed to mmap ROM");
        return 3;
    }
    printf("ROM image mapped at %p\n", rom);

    if (write_kernel(kernel_elf_fd, rom) == -1) {
        return 3;
    }

    if (munmap(rom, rom_size) == -1) {
        perror("Failed to munmap ROM");
    }
    if (close(out_fd) == -1) {
        perror("Failed to close output file");
    }

    return 0;
}
